#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Mar 6 07:41:52 2024
@author: jbacon, zshong
"""

""" README
Arguments:
    --seq_stats_tsv     (OPTIONAL) absolute path to tsv sheet for sequencing stats
                        if excluded figure titles simply won't include seq depth
    --cnr_dir           absolute path to directory of cnvkit fix output files
    --var_dir           absolute path to directory of table files converted from vcf
    --gene_list         (OPTIONAL) absolute path to txt file with list of ordered genes to plot
                        needs to have a header line, if excluded genes will be in alphabetical order
    --plot_output_dir   absolute path to output directory for violin plots
    --tsv_dataout_dir   absolute path to output directory for tsv data tables

Requirements:
    - please ensure that variant files within the var_dir are .table format which can be generated by running the
     following gatk command on vcf files:

    VariantsToTable \
    -V {input} \
    -F CHROM -F POS -F REF -F ALT -F TYPE -F FILTER -F STATUS -GF DP -GF VD -GF AF -GF ALD -GF RD -GF SBF -GF ODDRATIO \
    -F Func.refGene -F Gene.refGene -F ExonicFunc.refGene -F AAChange.refGene -F cosmic97_coding -F avsnp150 -F gnomad40_exome_AF -F CLNALLELEID -F CLNSIG \
    -O {output}

    - if a gene_list is provided for ordering the genes on the plot, please ensure that it has a header line
        the header line can be anything, i.e. "Genes", "Gene Names", etc.

Example Usage:
# with all arguments
python /groups/wyattgrp/users/amunzur/toolkit/visualization/plot_gene_violins.py \
    --seq_stats_tsv /groups/wyattgrp/users/jbacon/CGL_work/CGL_CNV_candidates/seq_metrics/seq_stats.tsv \
    --cnr_dir /groups/wyattgrp/users/jbacon/CGL_work/CGL_CNV_candidates/copynum/fix/genes/ \
    --var_dir /groups/wyattgrp/users/jbacon/CGL_work/CGL_CNV_candidates/mutations/mut_somatic/tables/ \
    --gene_list /groups/wyattgrp/users/jbacon/reference/panel_genelists/73gp.txt \
    --plot_output_dir /groups/wyattgrp/users/zshong/codebook/copynum_violin/ordered \
    --tsv_dataout_dir /groups/wyattgrp/users/zshong/codebook/copynum_violin/ordered

# without optional arguments
python /groups/wyattgrp/users/amunzur/toolkit/visualization/plot_gene_violins.py \
    --cnr_dir /groups/wyattgrp/users/jbacon/CGL_work/CGL_CNV_candidates/copynum/fix/genes/ \
    --var_dir /groups/wyattgrp/users/jbacon/CGL_work/CGL_CNV_candidates/mutations/mut_somatic/tables/ \
    --plot_output_dir /groups/wyattgrp/users/zshong/codebook/copynum_violin/ \
    --tsv_dataout_dir /groups/wyattgrp/users/zshong/codebook/copynum_violin/
"""
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use("Agg")
import math
import numpy as np
import os
import seaborn as sns
import argparse
from pathlib import Path

# function to apply label for copy status to violins plot entries
def get_copy_status_violin(row):
    if row['Chromosome'] in ['chrX', 'chrY']:
        return 'N/A'
    
    if (row['log2'] < -1):
        return 'Deep Deletion'
    elif (row['log2'] > 0.7):
        return 'Amplification'
    elif (-1 <= row['log2'] <= -0.3) or (-0.3 <= row['log2'] <= -0.15 and row['baf'] >= 0.55 and row['snp_count'] > 1):
        return 'Shallow Deletion'
    elif (0.3 <= row['log2'] <= 0.7) or (0.15 <= row['log2'] <= 0.3 and row['baf'] >= 0.55 and row['snp_count'] > 1):
        return 'Gain'
    elif (-0.15 <= row['log2'] <= 0.15 and row['baf'] >= 0.6 and row['snp_count'] > 1):
        return 'CN LOH'
    else:
        return 'Neutral'

# function that generates violin plot and summary tsv tables
def make_plot(samples, seq_stats, gene_list_file, plot_output_dir, cnrdir_violin, vardir_violin, targeted_output_dir):

    # IMPORT A LIST OF SNPS TO EXCLUDE DUE TO RECURRENT DEVIATION FROM 50% IN WBC DATA
    with open("/groups/wyattgrp/users/jbacon/reference/exclude_snps_CN.txt", 'r') as f:
        lines = f.readlines()
        values_to_remove = [(line.split()[0], int(line.split()[1])) for line in lines]
        values_set = set(values_to_remove)

    # Get Sequencing Statistics
    if seq_stats:
        seq_stats_df=pd.read_csv(seq_stats, sep='\t')
        seq_stats_df.set_index('SAMPLE', inplace=True)

    for sample in samples:
        if seq_stats:
            # extract sequencing depth
            seq_stats_df['TARGET COVERAGE (MEDIAN)'] = seq_stats_df['TARGET COVERAGE (MEDIAN)'].fillna(0)
            seq_stats_df['SNP COVERAGE (MEDIAN)'] = seq_stats_df['SNP COVERAGE (MEDIAN)'].fillna(0)
            depth=int(seq_stats_df.at[sample, 'TARGET COVERAGE (MEDIAN)'])
        
        #####################################################
        ######### Load and format the Violin data #########
        #####################################################
        
        if Path(cnrdir_violin+sample+'.cnr').exists():
            cnr_file = os.path.join(cnrdir_violin, sample+'.cnr')
        else:
            cnr_file = os.path.join(cnrdir_violin, sample+'.cnn.fix')

        if Path(vardir_violin+sample+".table").exists():
            var_file = os.path.join(vardir_violin, sample+".table")
        else:
            var_file = os.path.join(vardir_violin, sample+".tsv")
        
        log2_df_violin = pd.read_csv(cnr_file, sep='\t')
        vcf_violin = pd.read_csv(var_file, sep='\t')

        wbc_columns = vcf_violin.filter(regex=r"(?i)(WBC|gDNA)", axis=1).columns      
        paired_test = not wbc_columns.empty

        # Ensure there's no leading/trailing whitespace
        vcf_violin['Gene.refGene'] = vcf_violin['Gene.refGene'].str.strip()

        # Mapping of common mismapped gene annotations to replace
        replace_map = {
            r'ATM\\x3bC11orf65': 'ATM',
            'C11orf65': 'ATM',
            'GNAS-AS1': 'GNAS',
            'IDH2-DT': 'IDH2',
            'MTOR-AS1': 'MTOR',
            'LPAR6': 'RB1',
            'MFSD11': 'SRSF2',
            'MIR636': 'SRSF2',
            r'STAG2\\x3bSTAG2': 'STAG2',
            'TET2-AS1': 'TET2',
            r'U2AF1\\x3bU2AF1L5': 'U2AF1'
        }

        # Replace values in 'Gene.refGene' column
        vcf_violin['Gene.refGene'] = vcf_violin['Gene.refGene'].replace(replace_map, regex=True)

        # dump chrY
        log2_df_violin = log2_df_violin.loc[(log2_df_violin['chromosome'] != 'chrY')]
        vcf_violin = vcf_violin.loc[(vcf_violin['CHROM'] != 'chrY')]

        # Remove excluded SNPs
        snp_mask = vcf_violin.apply(lambda row: (row['CHROM'], row['POS']) not in values_set, axis=1)
        vcf_violin = vcf_violin[snp_mask]

        # load the list of genes to order by if provided
        if gene_list_file:
            with open(gene_list_file, 'r') as f:
                lines = f.readlines()
            # remove header
            gene_order_violin = [line.strip() for line in lines[1:]]
        # order genes alphabetically if no gene list is provided
        else:
            gene_order_violin = sorted(log2_df_violin['gene'].unique())

        #### Group by by gene and order by chromosome order 
        log2_df_violin['gene'] = pd.Categorical(log2_df_violin['gene'], categories=gene_order_violin, ordered=True)
        log2_df_violin = log2_df_violin.sort_values(by='gene')

        vcf_violin['Gene'] = pd.Categorical(vcf_violin['Gene.refGene'], categories=gene_order_violin, ordered=True)
        vcf_violin = vcf_violin.sort_values(by='Gene')
        
        if paired_test == True:   
            vcf_violin['VAF'] = vcf_violin[sample+'.VD'] / vcf_violin[sample+'.DP']
            
            wbc_vd_list = [x for x in wbc_columns if ".VD" in x]
            wbc_dp_list = [x for x in wbc_columns if ".DP" in x]
            
            if len(wbc_vd_list)==1 and len(wbc_dp_list)==1:
                wbc_vd=wbc_vd_list[0]
                wbc_dp=wbc_dp_list[0]
            else:
                raise ValueError("Can't locate the correct WBC columns, check your TSV header.")
            
            vcf_violin['WBC_VAF'] = vcf_violin[wbc_vd] / vcf_violin[wbc_dp]
            
            vcf_violin[["Alt_Fwd", "Alt_Rev"]] = vcf_violin.iloc[:, 20].str.split(",", expand=True)
            vcf_violin["Alt_Fwd"] = pd.to_numeric(vcf_violin["Alt_Fwd"], errors='coerce')
            vcf_violin["Alt_Rev"] = pd.to_numeric(vcf_violin["Alt_Rev"], errors='coerce')
            vcf_violin['ALT_RATIO'] = vcf_violin['Alt_Fwd'] / vcf_violin['Alt_Rev']
            
            vcf_violin=vcf_violin.loc[(vcf_violin['WBC_VAF'] < 0.55) &
                                        (vcf_violin['WBC_VAF'] > 0.45) &
                                        ((vcf_violin['ALT_RATIO'] > 0.33) & (vcf_violin['ALT_RATIO'] < 3))]

            #AGGRESIVELY REMOVE STRAND BIAS
            vcf_violin=vcf_violin.loc[(vcf_violin[sample+'.ODDRATIO'] < 3) &
                                        (vcf_violin[sample+'.ODDRATIO'] > 0.25) &
                                        (vcf_violin[sample+'.SBF'] > 0.05)]
            
            #REMOVE LOW DEPTH
            vcf_violin=vcf_violin.loc[vcf_violin[sample+'.DP'] > 25]
            
            #REMOVE IMPROPERLY DECOMPOSED
            vcf_violin=vcf_violin.drop_duplicates(subset=[sample+'.DP', sample+'.ALD', sample+'.RD','Gene'], keep=False)

            #REMOVE INDELS
            vcf_violin = vcf_violin[(vcf_violin['REF'].str.len() <= 1) & (vcf_violin['ALT'].str.len() <= 1)]
            
            #REFORMAT ALLELE FREQUENCY PLOT LIKE MATTI DOES
            vcf_violin['adj_VAF']=abs(0.5 - vcf_violin['VAF'])+0.5
                    
        elif paired_test == False:  
            vcf_violin['VAF'] = vcf_violin[sample+'.VD'] / vcf_violin[sample+'.DP']
            
            vcf_violin=vcf_violin.loc[(vcf_violin['VAF'] < 0.9) &
                                        (vcf_violin['VAF'] > 0.35)]
            
            #AGGRESIVELY REMOVE STRAND BIAS
            vcf_violin=vcf_violin.loc[(vcf_violin['ODDRATIO'] < 3) &
                                        (vcf_violin['ODDRATIO'] > 0.25) &
                                        (vcf_violin['SBF'] > 0.05)]
            
            #REMOVE LOW DEPTH
            vcf_violin=vcf_violin.loc[vcf_violin[sample+'.DP'] > 25]
            
            #REMOVE IMPROPERLY DECOMPOSED
            vcf_violin=vcf_violin.drop_duplicates(subset=[sample+'.DP', sample+'.ALD', sample+'.RD','Gene'], keep=False)

            #REMOVE INDELS
            vcf_violin = vcf_violin[(vcf_violin['REF'].str.len() <= 1) & (vcf_violin['ALT'].str.len() <= 1)]
            
            #REFORMAT ALLELE FREQUENCY PLOT LIKE MATTI DOES
            vcf_violin['adj_VAF']=abs(0.5 - vcf_violin['VAF'])+0.5

        ##### Filter out outlier probes #####
        gene_grouped_violin = log2_df_violin.groupby('gene', observed=False)

        # Filter rows where probe significantly deviates from local rolling average
        filtered_rows_violin = [
            group[abs(group['log2'] - group['log2'].rolling(window=3, min_periods=1, center=True).mean()) <= 0.3]
            for _, group in gene_grouped_violin]
                
        filtered_df_violin = pd.concat(filtered_rows_violin)
        filtered_df_violin.reset_index(drop=True, inplace=True)          
                         
        filtered_df_violin=log2_df_violin
        
        ### PLOTTING

        fig, (ax3, ax4) = plt.subplots(nrows=2, ncols=1,figsize=(18,8), height_ratios=[2,1])
        fig.set_size_inches(30, 10)
        
        # Create emptly lists to store targetted gene data
        median_log2_list = []
        median_vaf_list = []
        count_snp_list = []
        gene_list = []
        chromosome_list = []
        
        for gene in gene_order_violin:
            if gene in log2_df_violin['gene'].values:
                median_violin = log2_df_violin.loc[log2_df_violin['gene'] == gene, 'log2'].median()
                chromosome = log2_df_violin.loc[log2_df_violin['gene'] == gene, 'chromosome'].values[0]
            else:
                median_violin = np.nan  # Or use np.nan
                chromosome = None  # Or use 'Unknown'
            
            if gene in vcf_violin['Gene.refGene'].values:
                median_snp = vcf_violin.loc[vcf_violin['Gene.refGene'] == gene, 'adj_VAF'].median()
                count_snps = vcf_violin.loc[vcf_violin['Gene.refGene'] == gene].shape[0]
            else:
                median_snp = np.nan  # Or use np.nan
                count_snps = 0  # Default to zero
        
            # Append to lists
            median_log2_list.append(median_violin)
            median_vaf_list.append(median_snp)
            count_snp_list.append(count_snps)
            chromosome_list.append(chromosome)
            gene_list.append(gene)
            
        targeted_data = pd.DataFrame({
            'Sample_ID': [sample] * len(gene_list),
            'Chromosome': chromosome_list,
            'Gene': gene_list,
            'log2': median_log2_list,
            'baf': median_vaf_list,
            'snp_count': count_snp_list
        })
        
        targeted_data['copy_status'] = targeted_data.apply(get_copy_status_violin, axis=1)

        data_output_path=os.path.join(targeted_output_dir, sample)
        targeted_data.to_csv(data_output_path + ".tsv", sep='\t', index=False)
        print(f"\nsummary tsv file for {sample} successfully generated at {data_output_path+'.tsv'}")
        
        # Create a custom color palette
        colors = {}
        
        for index, gene in targeted_data.iterrows():
            gene_color = gene.iloc[2]
            log2_color = gene.iloc[3]
            baf_color = gene.iloc[4]
            count_color = gene.iloc[5]
            
            if log2_color < -1:
                colors[gene_color] = 'blue'
            elif log2_color > 0.7:
                colors[gene_color] = 'red'
            elif (-1 <= log2_color <= -0.3) or (-0.3 <= log2_color <= -0.15 and baf_color >= 0.55 and count_color > 1):
                colors[gene_color] = 'blue'
            elif (0.3 <= log2_color <= 0.7) or (0.15 <= log2_color <= 0.3 and baf_color >= 0.55 and count_color > 1):
                colors[gene_color] = 'red'
            elif (-0.15 <= log2_color <= 0.15 and baf_color >= 0.6 and count_color > 1):
                colors[gene_color] = 'green'
            else:
                colors[gene_color] = 'black'
            
        ### Set Plot Y-limits

        ## Calculate the upper limit
        # seg_max=max(median_log2_list) <- for using median of data
        seg_max = filtered_df_violin["log2"].max()

        rounded_max_value = math.ceil(seg_max * 2) / 2 # Round up to the nearest 0.5
        
        if rounded_max_value > 1.5:
            y_lim_high = rounded_max_value
        else:
            y_lim_high = 1.5
        
        ## Calculate the lower limit
        # seg_min=min(median_log2_list) <- for using median of data
        seg_min = filtered_df_violin["log2"].min()
        rounded_min_value = math.floor(seg_min * 2) / 2  # Round down to the nearest 0.5
        
        if rounded_min_value < -1.5:
            y_lim_low = rounded_min_value
        else:
            y_lim_low = -1.5
        
        # Apply the limits to the plot
        ax3.set_ylim(y_lim_low, y_lim_high)
        
        # Make violin plot
        # sns.violinplot(x='gene', y='log2', data=filtered_df_violin, inner=None, hue='gene',
        #                 edgecolor='none', palette=colors, linewidth=0, width=0.8, ax=ax3, density_norm='width',
        #                 bw_method=1.5, legend=False)
        

        genes = gene_list
        positions = np.arange(len(genes))

        violin_data = []
        empty_indices = []

        for idx, g in enumerate(genes):
            vals = filtered_df_violin.loc[filtered_df_violin['gene'] == g, 'log2'].values
            if len(vals) > 1:
                violin_data.append(vals)
            else:
                violin_data.append(None)   # mark empty/singleton
                empty_indices.append(idx)

        # Map gene names to positions for BAF plot alignment
        gene_to_pos = {gene: i for i, gene in enumerate(genes)}
        vcf_violin['x_pos'] = vcf_violin['Gene'].map(gene_to_pos)

        # --- Create figure and axes ---
        fig, (ax3, ax4) = plt.subplots(2, 1, sharex=True, figsize=(len(genes)*0.6, 8),
                                    gridspec_kw={'height_ratios': [3, 1]})

        # --- Plot violins for valid groups ---
        valid_data = [v for v in violin_data if v is not None]
        valid_positions = [i for i, v in enumerate(violin_data) if v is not None]

        violins = ax3.violinplot(
            valid_data,
            positions=valid_positions,
            showmeans=False,
            showmedians=False,
            showextrema=False
        )

        # Color violins
        for i, body in enumerate(violins['bodies']):
            body.set_facecolor(colors[genes[valid_positions[i]]])
            body.set_edgecolor('none')
            body.set_alpha(1.0)

        # --- Draw placeholders for empty/singleton groups ---
        for idx in empty_indices:
            ax3.plot([idx, idx], [y_lim_low, y_lim_high],
                    linestyle='dotted', color='gray', alpha=0.5)

        # --- Add gridlines ---
        # X gridlines
        for x_value in range(len(genes)):
            ax3.axvline(x_value, color='black', linestyle='--', linewidth=0.5, alpha=0.3)
            ax4.axvline(x_value, color='black', linestyle='--', linewidth=0.5, alpha=0.3)

        # Y gridlines for violin plot
        for y in np.arange(y_lim_low, y_lim_high, 0.5):
            ax3.axhline(y=y, color='k', linestyle='dotted', linewidth=0.75, alpha=0.5)
        ax3.axhline(y=0, color='k', linestyle='dotted', linewidth=1.25, alpha=0.75)

        # Y gridlines for BAF plot
        for y in np.arange(0.5, 1.0, 0.1):
            ax4.axhline(y=y, color='k', linestyle='dotted', linewidth=0.75, alpha=0.3)

        # --- BAF scatter plot ---
        ax4.scatter(vcf_violin['x_pos'], vcf_violin['adj_VAF'], color='k', alpha=0.7)

        # --- Configure axes ---
        # Violin plot (ax3)
        ax3.spines['top'].set_linestyle('dotted')
        ax3.spines['top'].set_linewidth(0.75)
        ax3.spines['top'].set_alpha(0.5)
        ax3.tick_params(axis='x', which='both', bottom=False, labelbottom=False)
        ax3.tick_params(axis='y', which='major', labelsize=12)
        ax3.set_ylabel("Log Ratio", fontsize=14)
        ax3.set_xlabel("")

        # BAF plot (ax4)
        ax4.spines['top'].set_linestyle('dotted')
        ax4.spines['top'].set_linewidth(0.75)
        ax4.spines['top'].set_alpha(0.5)
        ax4.set_xticks(positions)
        ax4.set_xticklabels(genes, rotation=90, fontsize=12)
        ax4.tick_params(axis='y', which='major', labelsize=12)
        ax4.set_ylabel("BAF", fontsize=14, labelpad=16)
        ax4.set_xlabel("Gene", fontsize=14, labelpad=12)
        ax4.set_ylim(0.5, 1.0)

        # Set consistent x-limits
        ax3.set_xlim(-0.5, len(genes)-0.5)
        ax4.set_xlim(-0.5, len(genes)-0.5)

        title = f"{sample}_matched\n{cnr_file}\n{var_file}" if paired_test else f"{sample}\n{cnr_file}\n{var_file}"
        full_title = f"{title}\nTarget Depth: {depth}x" if seq_stats else title
        ax3.set_title(full_title, fontsize=18, pad=16)
        
        sample_plot_path=os.path.join(plot_output_dir, sample)

        fig.savefig(sample_plot_path + '.pdf', dpi=300, bbox_inches='tight')
        fig.savefig(sample_plot_path + '.png', dpi=300, bbox_inches='tight')
        print(f"\nviolin plot for {sample} successfully generated at {sample_plot_path + '.png'} and {sample_plot_path + '.pdf'}")
        
        matplotlib.pyplot.close()

def main():
    parser = argparse.ArgumentParser(
        description="Generate violin plots from CNVkit fix results and variant calling VCF files"
    )

    parser.add_argument("--seq_stats_tsv", required=False, default=None, help="absolute path to tsv sheet for sequencing stats")
    parser.add_argument("--var_dir", required=True, help="absolute path to directory of vcf files")
    parser.add_argument("--cnr_dir", required=True, help="absolute path to directory of cnvkit fix output files")
    parser.add_argument("--gene_list", required=False, default=None, help="absolute path to txt file with list of ordered genes to plot")
    parser.add_argument("--plot_output_dir", required=True, help="absolute path to output directory for violin plots")
    parser.add_argument("--tsv_dataout_dir", required=True, help="absolute path to output directory for tsv data tables")

    args = parser.parse_args()
    
    os.makedirs(args.plot_output_dir, exist_ok=True)
    os.makedirs(args.tsv_dataout_dir, exist_ok=True)

    # find samples with both cnr and vcf files
    cnr_files = sorted([f.split(".")[0] for f in os.listdir(args.cnr_dir) if f.endswith(".cnr") or f.endswith(".cnn.fix")])
    var_files = sorted([os.path.splitext(f)[0] for f in os.listdir(args.var_dir) if f.endswith(".table") or f.endswith(".tsv")])
    samples = sorted(list(set(cnr_files) & set(var_files)))

    if not samples:
        raise ValueError('No matching vcf and cnr files found in the given directories')

    make_plot(samples, args.seq_stats_tsv, args.gene_list, args.plot_output_dir,
                args.cnr_dir, args.var_dir, args.tsv_dataout_dir)
    
    print(f"\nPlots generated in: {args.plot_output_dir}")
    print(f"Summary tsv tables for each sample in: {args.tsv_dataout_dir}")

if __name__ == "__main__":
    main()


